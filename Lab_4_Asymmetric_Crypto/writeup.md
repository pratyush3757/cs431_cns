## 01 CipherSailor: Crack the RSA Code!
### Challenge Text

Ahoy, codebreaker! üåä
Welcome aboard the CipherSailor challenge, where your cryptographic skills will be put to the ultimate test. üè¥‚Äç‚ò†Ô∏è

Challenge Overview:
In this challenge, you're tasked with cracking a seemingly unbreakable RSA encryption. As a fearless CipherSailor, your mission is to retrieve the hidden passcode and claim the treasure‚Äîa coveted flag!

Your Mission:
Connect to our server using netcat on port 5050.
Retrieve the public key details (n, e) and the encrypted message (c).
Decrypt the message and reveal the passcode.
Submit the correct passcode to retrieve the flag. ‚öì
Are you ready to crack the code and earn your title as the ultimate CipherSailor?
Set sail, and good luck! ‚õµüèÜ
`nc 10.0.118.104 5050`

On connecting to the server, we get the following details:
```
Ahoy, codebreaker! Welcome to the Ultimate (But an eeeasy one!) RSA Encryption Challenge!

Here's your mission, should you choose to accept it:
Public Key Details (n, e):
n = 693416694874441282487742338680322035414956190228240540936668894129857295289298006662727249980045738596177349867192173289730550848522197935038173521014202992781976472820107508606309981646083331010408788638763381621721082846632077731165211438126434974363866402228201362863970322049497416754173219894613962579291613012396175690800721462242675514254313569383252394030021103051871527782802957899019150692495188163505418025322953759428312881056425884307995464112034994645183714476639647141373858094787283714867733897329659485719598486408566159828547199454831233111319781127491008552175376782304691228877020976227920673794327522585413868412137876468551976320027485415405993081681399578259540074299497922750735546441112297246603431013736705181286201470085530763712783553403222765792387443395109947238423636809707248960797769782885634558760647191339664182000465557653344144805220886915934539604468334414731613214983441793587508580130848339059938184318569222721908638685604164143169693676602097656394668866962299145396449640621795481301541445625348678295780699894243449689563939259278929962478146528886344712658626558126237294399530686235030978958206738809598722224687504383073563985699099345370637443811452992184819559495810535689508113803019
e = 5
Encrypted Message (c):
c = 8397807126034698141894870273160698970580559462637749063850451431139297578400476522913163177634017340306337512271309890206455616958209847219672015004224907078461592165746116946954734273701232109475078897800704866453439337294167762610969388300160263884345203773946188532683434548646899304992356962447128490706642442593409197987471412719261315529532536022953135017761540546872247637897082010899471009636885853273822361118949789438199529052819145978251134587570032117192433463878039900485845916836359174366386528840424905184378820736644733278273714916568451441909311272117773515784513941463207969016416165188903980077062748416789684336296361725610940539028379049925562286392175654201509265272901592279795649847599021604058941538935295849615748603791882890287576074582777748112220757615259198179831568488415447884812654390251901756343945679376384004468659281206295326002509536305637819826511976907547251864001229438341563687335803416115326142703945949523092439996893820248542638111508078862058744831894900407237717575901436567033804094584785226993519465808393802253523448832

Crack the code and reveal the passcode: 
```


### Solution

There are several popular RSA attacks, one of them is the Small Exponent Attack.    
Specifically, if the exponent `e` is sufficiently small, it becomes ineffective at encrypting the message `m`.

Let's say `m^e < N`; in this case, we can simply take the `e-th root` of `c`. For example, if `e = 3`, then we can calculate `m = c^(1/3)`.

If `m^e > N`, then it's more secure, but we can progressively add multiples of `N` until the cube root gives us a valid answer:

`m = (c + k * N)^(1/3)`

Here's an article summarizing some popular attacks on RSA: [A Brief Summary of Attacks on RSA](https://www.rose-hulman.edu/class/ma/holden/Archived_Courses/Math479-0304/resources/attacks-rsa/).

Given the public key `(n, e)` and the encrypted message `c`, we can decrypt the message using the following Python script (assuming the exponent `e` is small and `m^e < N`):

```python
import gmpy2

# RSA Parameters: n, e, c
n = 693416694874441282487742338680322035414956190228240540936668894129857295289298006662727249980045738596177349867192173289730550848522197935038173521014202992781976472820107508606309981646083331010408788638763381621721082846632077731165211438126434974363866402228201362863970322049497416754173219894613962579291613012396175690800721462242675514254313569383252394030021103051871527782802957899019150692495188163505418025322953759428312881056425884307995464112034994645183714476639647141373858094787283714867733897329659485719598486408566159828547199454831233111319781127491008552175376782304691228877020976227920673794327522585413868412137876468551976320027485415405993081681399578259540074299497922750735546441112297246603431013736705181286201470085530763712783553403222765792387443395109947238423636809707248960797769782885634558760647191339664182000465557653344144805220886915934539604468334414731613214983441793587508580130848339059938184318569222721908638685604164143169693676602097656394668866962299145396449640621795481301541445625348678295780699894243449689563939259278929962478146528886344712658626558126237294399530686235030978958206738809598722224687504383073563985699099345370637443811452992184819559495810535689508113803019
e = 5
c = 8397807126034698141894870273160698970580559462637749063850451431139297578400476522913163177634017340306337512271309890206455616958209847219672015004224907078461592165746116946954734273701232109475078897800704866453439337294167762610969388300160263884345203773946188532683434548646899304992356962447128490706642442593409197987471412719261315529532536022953135017761540546872247637897082010899471009636885853273822361118949789438199529052819145978251134587570032117192433463878039900485845916836359174366386528840424905184378820736644733278273714916568451441909311272117773515784513941463207969016416165188903980077062748416789684336296361725610940539028379049925562286392175654201509265272901592279795649847599021604058941538935295849615748603791882890287576074582777748112220757615259198179831568488415447884812654390251901756343945679376384004468659281206295326002509536305637819826511976907547251864001229438341563687335803416115326142703945949523092439996893820248542638111508078862058744831894900407237717575901436567033804094584785226993519465808393802253523448832

# Try to find the e-th root of c using gmpy2
m, exact = gmpy2.iroot(c, e)

# Check if we found the exact root
if exact:
    print("Exact root found!")
    # Convert the integer back to a string
    msg_bytes = int(m).to_bytes((int(m).bit_length() + 7) // 8, byteorder='big')
    msg = msg_bytes.decode('utf-8')
    print(f"Decrypted message: {msg}")
else:
    print("Exact root not found, the method didn't work, may try progressive multiples of N")
```
If we run the script, we get the passcode as:
`K3yT0$ucc3$$!sSm@rtW0rk#2024`.   
Providing this passcode to the server gives us the flag.
### Flag
`CNS431{r5a_5t4t3_0f_4ff41r5}`

## 02 Alice's Signature Mix-Up
### Challenge Text
In the early 2000s, Alice was signing a message for Bob using digital signatures. Faced with limited documentation, she was confused by the two keys involved. In a rush, Alice computed the hash of the message and used RSA to sign the hash, sending both the message and the signed hash to Bob.

Bob, puzzled by the unusual signing method, suspected something was amiss.

Now, it's up to you to uncover the issue and find it!

Connect here!
`nc 10.0.118.104 1234`

Hint: 

hash(m): sum of the ASCII values of each character in m.

e.g., the hash("ABC") = 198

Connecting to the server, we get the following details:
```
Welcome to Alice's Signature Mix-Up Challenge!

Your mission is to find out how she did it.
Public Key Details (n, e):
n = 102248944243793181444557153561211333867456218095241951053769434033693336214890761517157179549932164911267137439900850687424837751140870524185525532258888267082198586595828420321997562510845828663920147126367174901806517223769490510341561346926003095345359311329966657444456707371891964757336383820477684444029
e = 65537
Secret Message:
Hello Bob! This is a secret message, to be kept within CNS431.

Provide the 'signed hash' of the message to uncover the flag:
```
### Solution
In Digital Signatures, to sign any message we perform the following steps:
- **Hash the Message**: First, the original message (or data) is hashed using a cryptographic hash function (e.g., SHA-256). The hash is a fixed-size string that uniquely represents the message.
- **Sign the Hash**: Using your private key, you encrypt the hash. This encrypted hash is your digital signature. Since only you have access to your private key, this signature verifies that you are the one who signed the message.
- **Send the Message and Signature**: The message and the digital signature are sent together to the recipient.

In the problem statement, Alice computed the hash of the message using a hash function and then signed the hash using RSA. 
First of all, the hash function used by Alice is the sum of the ASCII values of each character in the message, which is a collision-prone hash function. This should not be used in practice.

The problem asks us to find the signed hash of the message. To do this, we need to:
- Calculate the hash of the message using the provided hash function.
- Sign the hash using the private key of Alice.
- Provide the signed hash to the server to get the flag.
But, we don't have the private key of Alice. So, we need to find a way to forge the signature without the private key. The problem description also hints that Alice was confused by the two keys involved. So, maybe Alice used the public key to sign the hash. If this is the case, we can forge the signature using the public key.

Here's a Python script to forge the signature using the public key:
```python
import hashlib

# Simple hash function (sum of ASCII values)
def simple_hash(msg):
    return sum(ord(char) for char in msg)

# Given public key details
n = 102248944243793181444557153561211333867456218095241951053769434033693336214890761517157179549932164911267137439900850687424837751140870524185525532258888267082198586595828420321997562510845828663920147126367174901806517223769490510341561346926003095345359311329966657444456707371891964757336383820477684444029
e = 65537


# Message to sign
message = "Hello Bob! This is a secret message, to be kept within CNS431."

# Hash the message
hashed_message = simple_hash(message)

# now sign the hash using e
signature = pow(hashed_message, e, n)


# Print the signature
print("Signature:", signature)
```

Running the script, we get the signature as: `68658254461997077314834450008079793557171431664482388215303796241161918559074205980521327749615999459428927973985852236880504572177978774577054221367978540962091666424978175301583774266568728592073984976731704511295047693430028304625864393974289388581358680106460875659299778931335499245579484715497864766490`.   
Providing this signature to the server gives us the flag.

### Flag
`CNS431{@l1c3_m@d3_@_k3y_mist@k3}`